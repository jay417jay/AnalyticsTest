var TcHmi;!function(t){!function(t){!function(t){class e extends t.LineAreaChannel{constructor(t,e,i,n,s,l,o,_,a){super(t,e,i,n,s,l,o,_,a),this.__options=a}drawChannel(e,i,n=5,s=-1){let l=t.AlyMath.min(e.map(t=>t.timestamp));if(-1!=s&&(l=s),null!=i&&i){l=this.__getVisibleMinTimestamp(this.__props.dataRequestTime);new t.SPTime(l)}let o=[],_=[],a=-1,h=-1;const m=this.__getTimeDifference(e);for(let i=0;i<e.length;i++){const s=e[i],r=Math.round((s.timestamp-l)*this.__xStepDistance+this.__offsetLeft);new t.SPTime(s.timestamp);if(null==s.values[0]||s.timestamp<l){a=s.timestamp;continue}if(-1!=a&&s.timestamp-m!=a&&h<r-n){this.__createLinie(o,!1),o=[],this.__options.fillMode==t.EFillMode.FILL&&(this.__createLinie(_,!0),_=[]),a=s.timestamp,h=r;continue}h=r,a=s.timestamp;const c=Math.round(this.__offsetTop-s.values[0]*this.__yStepDistance);let f=this.__createPoint(r,c,!1);0==o.length&&(o=this.__createPointsList(r,c,!1),this.__options.fillMode==t.EFillMode.FILL&&(_=this.__createPointsList(r,c,!0))),o.push(f),this.__options.fillMode==t.EFillMode.FILL&&_.push(this.__createPoint(r,c,!0))}this.__createLinie(o,!1),this.__options.fillMode==t.EFillMode.FILL&&this.__createLinie(_,!0)}__getTimeDifference(t){if(t.length<2)return 0;const e=t.map(t=>t.timestamp).filter(t=>null!=t&&null!=t);e.sort((t,e)=>t-e);let i=null,n=null;for(let t=0;t<e.length;t++)if(null===i)i=e[t];else if(e[t]!==i){n=e[t];break}return null!==i&&null!==n?n-i:0}}t.YTChannel=e}(t.Analytics||(t.Analytics={}))}(t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));