var TcHmi;!function(t){!function(t){!function(t){class e extends t.TimeCompareGridBasedChart{constructor(t,e,s){super(t,e,s),this.__timeDifferencesInTc=[],this.__options=s}createInitChart(){this.__preCreateInitChart(),this.createChart(this.__initData),this.__postCreateInitChart()}createChart(e){switch(this.__preCreateChart(e),this.__numberOfXAxes=this.__options.compareType==t.ECompareChartCompareTypes.ABSOLUTE_TIME?this.__options.timeranges.filter(t=>t.isVisible).length:1,this.__intervalSizes=this.__options.timeranges.map(e=>t.TimeConverter.getToTcTime(e,this.__props.dataRequestTime,this.__options.compareInterval)-t.TimeConverter.getFromTcTime(e,this.__props.dataRequestTime)),this.__maxIntervalSize=Math.max(...this.__intervalSizes),this.__createYAxes(),this.__options.compareType){case t.ECompareChartCompareTypes.RELATIVE_TIME:this.__createRelativeTimerangeChart(e);break;case t.ECompareChartCompareTypes.ABSOLUTE_TIME:this.__createAbsoluteTimerangeChart(e);break;case t.ECompareChartCompareTypes.MATCHING_END:case t.ECompareChartCompareTypes.MATCHING_START:this.__createCombinedTimerangeChart(e)}this.__postCreateChart()}__createCombinedTimerangeChart(e){this.__timeDifferencesInTc=[];let s=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin,i=this.__yAxes[0].top+this.__props.defaultAxisMargin;const n=new t.Point(s,i),a=new t.Point(this.elParent.clientWidth-this.__props.svgChartBorderdistance-this.__yAxes[0].width,i),o=t.TimeConverter.getFromTcTime(this.__options.timeranges[0],this.__props.dataRequestTime),_=t.TimeConverter.getFromTcTime(this.__options.timeranges[0],this.__props.dataRequestTime)+this.__options.compareIntervalSizeMs*t.SPTime.TIME_IN_MS_TO_TC_FACTOR;let r=[];r.push({timestamp:o,values:[]}),r.push({timestamp:_,values:[]});const h=Object.assign(Object.assign({},this.__options),{labelSuffix:""}),p=new t.XVirtualAxis(this.elParent,this.__props,h);this.__xAxes.push(p),p.drawAxis(n,a,r),this.__createChartBackground();let l=0;s=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin;for(let i=0;i<this.__options.timeranges.length;i++){if(!this.__options.timeranges[i].isVisible){this.__timeDifferencesInTc.push(0),l+=e.symbols.length;continue}const n=0,a=0,o=t.TimeDiffHelper.calculateTimeDiffMs(this.__options.timeranges[i],this.__options.compareInterval.rangeUnit,this.__options.timeranges[0],this.__options.compareType,this.__options.compareInterval,this.__props.dataRequestTime)*t.SPTime.TIME_IN_MS_TO_TC_FACTOR;this.__timeDifferencesInTc.push(o);for(let _=0;_<e.symbols.length;_++){const r=e.symbols[_],h=this.__channelDataValues.find(t=>t.channelConfig==this.__options.channelConfigurations[l]);let p=null;p=new t.YVirtualChannel(r,this.__elChartBackground,this.__props,this.__xAxes[n].stepDistance,s,-this.__yAxes[a].stepDistance,this.__yAxes[a].nullpoint,this.__options.channelConfigurations[l],this.__xAxes[n],this.__options.timeranges[i],o,"",String(i+1),i*this.__props.channelColorReducer,this.__options),this.__options.channelConfigurations[l].isVisible&&(null!=h&&p.drawChannel(h.channelData,this.__xPosSplitter),this.__channels.push(p)),l++}}}__createAbsoluteTimerangeChart(e){for(let e=0;e<this.__options.timeranges.length;e++){if(!this.__options.timeranges[e].isVisible)continue;let s=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin,i=1==this.__yAxes.length&&1==this.__numberOfXAxes?this.__yAxes[0].top:this.__yAxes[0].top+this.__defaultXAxisHeight*e;i+=this.__props.defaultAxisMargin;const n=t.TimeConverter.getFromTcTime(this.__options.timeranges[e],this.__props.dataRequestTime),a=n+this.__maxIntervalSize,o=t.TimeConverter.getToTcTime(this.__options.timeranges[e],this.__props.dataRequestTime,this.__options.compareInterval);let _=[];_.push({timestamp:n,values:[]}),_.push({timestamp:a,values:[]});const r=new t.XTAxis(this.elParent,this.__props,this.__options),h=new t.Point(s,i),p=new t.Point(this.elParent.clientWidth-this.__props.svgChartBorderdistance-this.__yAxes[0].width,i);this.__xAxes.push(r),r.drawAxis(h,p,_,o,!1)}this.__createChartBackground();let s=0,i=0,n=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin;for(let a=0;a<this.__options.timeranges.length;a++){if(!this.__options.timeranges[a].isVisible){i++,s+=e.symbols.length;continue}const o=a,_=0;for(let r=0;r<e.symbols.length;r++){const h=e.symbols[r],p=this.__channelDataValues.find(t=>t.channelConfig==this.__options.channelConfigurations[s]);let l=null;l=new t.YTChannel(h,this.__elChartBackground,this.__props,this.__xAxes[o-i].stepDistance,n,-this.__yAxes[_].stepDistance,this.__yAxes[_].nullpoint,this.__options.channelConfigurations[s],Object.assign(Object.assign({},this.__options),{channelColorReducer:a*this.__props.channelColorReducer,strokeWidth:String(1)})),this.__options.channelConfigurations[s].isVisible&&(null!=p&&l.drawChannel(p.channelData,!1,this.__xPosSplitter,t.TimeConverter.getFromTcTime(this.__options.timeranges[a],this.__props.dataRequestTime)),this.__channels.push(l)),s++}}}__createRelativeTimerangeChart(e){const s=new t.XIntervalAxis(this.elParent,this.__props,this.__options);let i=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin,n=this.__yAxes[0].top+this.__props.defaultAxisMargin;const a=new t.Point(i,n),o=new t.Point(this.elParent.clientWidth-this.__props.svgChartBorderdistance-this.__yAxes[0].width,n);this.__xAxes.push(s),s.drawAxis(a,o,e.data,Math.max(...this.__intervalSizes)),this.__createChartBackground();let _=0;i=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin;for(let s=0;s<this.__options.timeranges.length;s++){if(!this.__options.timeranges[s].isVisible){_+=e.symbols.length;continue}const n=0,a=0;for(let o=0;o<e.symbols.length;o++){const r=e.symbols[o],h=this.__channelDataValues.find(t=>t.channelConfig==this.__options.channelConfigurations[_]);let p=null;const l=i;p=new t.YIntervalChannel(r,this.__elChartBackground,this.__props,this.__xAxes[n].stepDistance,l,-this.__yAxes[a].stepDistance,this.__yAxes[a].nullpoint,this.__options.channelConfigurations[_],Object.assign(Object.assign({},this.__options),{channelColorReducer:s*this.__props.channelColorReducer,strokeWidth:String(1)})),this.__options.channelConfigurations[_].isVisible&&(null!=h&&p.drawChannel(h.channelData,this.__xPosSplitter,t.TimeConverter.getFromTcTime(this.__options.timeranges[s],this.__props.dataRequestTime)),this.__channels.push(p)),_++}}}__createChannelValues(){const e=JSON.parse(JSON.stringify(this.__options.data));this.__channelDataValues=[];let s=0;if(null!=this.__options.timeranges)for(const i of this.__options.timeranges){if(!i.isVisible){s+=e.symbols.length;continue}let n=t.TimeConverter.getFromTcTime(i,this.__props.dataRequestTime);const a=t.TimeConverter.getToTcTime(i,this.__props.dataRequestTime,this.__options.compareInterval);if(this.__options.compareType===t.ECompareChartCompareTypes.MATCHING_START){const e=t.TimeDiffHelper.calculateTimeDiffMs(i,this.__options.compareInterval.rangeUnit,this.__options.timeranges[0],this.__options.compareType,this.__options.compareInterval,this.__props.dataRequestTime)*t.SPTime.TIME_IN_MS_TO_TC_FACTOR,s=this.__options.timeranges[0],a=t.TimeConverter.getFromTcTime(s,this.__props.dataRequestTime),o=t.TimeConverter.getFromTcTime(i,this.__props.dataRequestTime)-e;n+=a-o}for(let t=0;t<this.__options.data.symbols.length;t++){let o=e.data.map(e=>Object.assign(Object.assign({},e),{values:[e.values[t]]}));if(o=o.filter(t=>t.timestamp<=a&&t.timestamp>=n&&null!=t.values[0]),0==o.length){s++;continue}if(this.__options.showDifferentials){let t=JSON.parse(JSON.stringify(o[0].values[0]));for(const e of o)null!=e.values[0]&&(e.values[0]-=t)}const _={};_.timerange=i,_.channelConfig=this.__options.channelConfigurations[s],_.channelData=[...o],this.__channelDataValues.push(_),s++}}}getValues(e,s){const i=[];let n=0;for(let a=0;a<this.__options.timeranges.length;a++){if(!this.__options.timeranges[a].isVisible){n+=this.__options.data.symbols.length;continue}const o=this.__options.timeranges[a],_=t.TimeConverter.getFromTcTime(o,this.__props.dataRequestTime),r=t.TimeConverter.getToTcTime(o,this.__props.dataRequestTime,this.__options.compareInterval);let h=t.TimeConverter.getFromTcTime(o,this.__props.dataRequestTime);this.__options.compareType!==t.ECompareChartCompareTypes.MATCHING_END&&this.__options.compareType!==t.ECompareChartCompareTypes.MATCHING_START||(h=this.__xAxes[0].minValue);for(let o=0;o<this.__options.data.symbols.length;o++){const p=this.__channelDataValues.find(t=>t.channelConfig==this.__options.channelConfigurations[n]);if(null==p||null==p.channelData||0==p.channelData.length){n++;continue}let l=Math.round(e-this.__xAxes[0].left)/this.__xAxes[0].stepDistance+h,m=0;this.__options.compareType!==t.ECompareChartCompareTypes.MATCHING_END&&this.__options.compareType!==t.ECompareChartCompareTypes.MATCHING_START||(l+=this.__timeDifferencesInTc[a]);const c=p.channelData.filter(t=>null!==t.values[o]).map(t=>t.timestamp).reduce((t,e)=>Math.abs(e-l)<Math.abs(t-l)?e:t),T=p.channelData.filter(t=>t.timestamp===c)[0];if(_>T.timestamp||r<T.timestamp){n++;continue}let u=0,C=null;if(i.some(t=>t.timestamp===T.timestamp)){i.find(t=>t.timestamp==T.timestamp).values[o]=T.values[0]}else{const t={timestamp:T.timestamp,values:[],hoverChannel:null};i.push(t),t.values[o]=T.values[0]}u=this.__timeDifferencesInTc[a];let g=Math.round((T.timestamp-h)*this.__xAxes[0].stepDistance+this.__xAxes[0].left);if(this.__options.compareType===t.ECompareChartCompareTypes.MATCHING_END||this.__options.compareType===t.ECompareChartCompareTypes.MATCHING_START){const t=T.timestamp-u;g=Math.round((t-this.__xAxes[0].minValue+m)*this.__xAxes[0].stepDistance+this.__xAxes[0].left)}if(isNaN(g)||g>this.__xAxes[0].endPoint.x||g<this.__xAxes[0].startPoint.x){n++;continue}if(!this.__options.channelConfigurations[n].isVisible||null==T.values[0]){n++;continue}const f=Math.round(this.__yAxes[0].nullpoint+T.values[0]*this.__yAxes[0].stepDistance);let d=new t.SVGCircle(g,f,this.__options.hoverPointRadius,["tchmi-analytics-charting-hover-circle"]);const x=this.__options.channelConfigurations[n].varColor;d.fill=x,d.stroke="black",d.appendTo(this.__elChartBackground),this.__hoverPoints.push(d),d.cX-d.radius<=e&&e<=d.cX+d.radius&&d.cY-2*d.radius<=s&&s<=d.cY+2*d.radius&&null!=C&&(C.hoverChannel=this.__options.data.symbols[o]),n++}}return i}}t.CompareYTChart=e}(t.Analytics||(t.Analytics={}))}(t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));