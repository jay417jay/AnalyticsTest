var TcHmi;!function(t){!function(t){!function(t){class s extends t.GridBasedChart{constructor(t,s,e){super(t,s,e),this.__options=e}createInitChart(){this.__preCreateInitChart(),this.__options.timeranges=[];for(const s of this.__initTimeranges){const e={isVisible:!0};let i=t.TimeParser.parseStringToDate(s.from,!0);e.from=t.TimeParser.parseDateToString(i,!1),i=t.TimeParser.parseStringToDate(s.to,!0),e.to=t.TimeParser.parseDateToString(i,!1),this.__options.timeranges.push(e)}this.__options.fillMode=t.EFillMode.FILL,this.createChart(this.__initData),this.__postCreateInitChart()}createChart(s){if(this.__options.channelConfigurations.length<s.symbols.length)return;this.__preCreateChart(s),this.__createYAxes();const e=new t.XTAxis(this.elParent,this.__props,this.__options);let i=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin,n=1==this.__yAxes.length&&1==this.__numberOfXAxes?this.__yAxes[0].top:this.elParent.clientHeight-this.__defaultXAxisHeight;n+=this.__props.defaultAxisMargin;const a=new t.Point(i,n),o=new t.Point(this.elParent.clientWidth-this.__props.svgChartBorderdistance-this.__yAxes[0].width,n);this.__minTimestamp=this.__getVisibleMinTimestamp(this.__props.dataRequestTime);const h=this.__getMaxVisibleTimestamp(this.__props.dataRequestTime);let _=[];_.push({timestamp:this.__minTimestamp,values:[]}),_.push({timestamp:h,values:[]}),e.drawAxis(a,o,_),this.__xAxes.push(e),this.__createChartBackground();let r=JSON.parse(JSON.stringify(s.data)),l=[];for(const s of this.__options.timeranges)if(s.isVisible){const e=t.TimeConverter.getFromTcTime(s,this.__props.dataRequestTime),i=t.TimeConverter.getToTcTime(s,this.__props.dataRequestTime),n=r.filter(t=>t.timestamp<=i&&t.timestamp>=e);l.push(...n)}l.sort((t,s)=>t.timestamp>s.timestamp?1:-1),i=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin;for(let e=0;e<s.symbols.length;e++){if(!this.__options.channelConfigurations[e].isVisible)continue;const n=0,a=0,o=s.symbols[e],h=this.__channelDataValues.find(t=>t.channelConfig==this.__options.channelConfigurations[e]),_=new t.YTChannel(o,this.__elChartBackground,this.__props,this.__xAxes[n].stepDistance,i,-this.__yAxes[a].stepDistance,this.__yAxes[a].nullpoint,this.__options.channelConfigurations[e],this.__options);null!=h&&_.drawChannel(h.channelData,!0,this.__xPosSplitter),this.__channels.push(_)}this.__postCreateChart()}__createChannelValues(){const s=JSON.parse(JSON.stringify(this.__options.data));this.__channelDataValues=[];const e=[];for(const i of this.__options.timeranges){if(!i.isVisible)continue;const n=t.TimeConverter.getFromTcTime(i,this.__props.dataRequestTime),a=t.TimeConverter.getToTcTime(i,this.__props.dataRequestTime);e.push(...s.data.filter(t=>t.timestamp<=a&&t.timestamp>=n))}for(let t=0;t<this.__options.data.symbols.length;t++){let s=e.map(s=>Object.assign(Object.assign({},s),{values:[s.values[t]]}));if(0==s.length)continue;if(this.__options.showDifferentials){let t=JSON.parse(JSON.stringify(s[0].values[0]));for(const e of s)null!=e.values[0]&&(e.values[0]-=t)}const i={};i.channelConfig=this.__options.channelConfigurations[t],i.channelData=[...s],this.__channelDataValues.push(i)}}getValues(s,e){const i=[];for(let t=0;t<this.__options.data.symbols.length;t++){const e=Math.round(s-this.__xAxes[0].left)/this.__xAxes[0].stepDistance+this.__minTimestamp,n=this.__channelDataValues.find(s=>s.channelConfig==this.__options.channelConfigurations[t]);if(null==n||null==n.channelData||0==n.channelData.length)continue;const a=n.channelData.filter(s=>null!==s.values[t]).map(t=>t.timestamp).reduce((t,s)=>Math.abs(s-e)<Math.abs(t-e)?s:t),o=n.channelData.filter(t=>t.timestamp===a)[0];if(i.some(t=>t.timestamp===o.timestamp)){i.find(t=>t.timestamp==o.timestamp).values[t]=o.values[0]}else{const s={timestamp:o.timestamp,values:[],hoverChannel:null};i.push(s),s.values[t]=o.values[0]}}for(const n of i){const i=Math.round((n.timestamp-this.__minTimestamp)*this.__xAxes[0].stepDistance+this.__xAxes[0].left);for(let a=0;a<n.values.length;a++){if(!this.__options.channelConfigurations[a].isVisible||null==n.values[a])continue;const o=Math.round(this.__yAxes[0].nullpoint+n.values[a]*this.__yAxes[0].stepDistance);let h=new t.SVGCircle(i,o,this.__options.hoverPointRadius,["tchmi-analytics-charting-hover-circle"]);const _=t.Str.hexToRgbA(this.__options.channelConfigurations[a].varColor);h.fill=_,h.stroke="black",h.appendTo(this.__elChartBackground),this.__hoverPoints.push(h),h.cX-h.radius<=s&&s<=h.cX+h.radius&&h.cY-2*h.radius<=e&&e<=h.cY+2*h.radius&&(n.hoverChannel=this.__options.data.symbols[a])}}return i}}t.YTChart=s}(t.Analytics||(t.Analytics={}))}(t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));