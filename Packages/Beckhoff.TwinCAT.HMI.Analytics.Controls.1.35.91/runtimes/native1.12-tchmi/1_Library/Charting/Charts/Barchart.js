var TcHmi;!function(t){!function(t){!function(t){class s extends t.GridBasedChart{constructor(t,s,e){super(t,s,e),this.__options=e}createInitChart(){this.__preCreateInitChart(),this.createChart(this.__initData),this.__postCreateInitChart()}createChart(s){var e;if(this.__channelValues=[],this.__preCreateChart(s),null==this.__options.timeranges||0==this.__options.timeranges.length)return void console.error("No timerange added to bar chart");this.__createYAxes();const i=t.AlyMath.max(this.__yAxes.map(t=>t.left+t.width))+this.__props.defaultAxisMargin;let n=1==this.__yAxes.length&&1==this.__numberOfXAxes?this.__yAxes[0].top:this.elParent.clientHeight;n+=this.__props.defaultAxisMargin;const a=new t.Point(i,n),o=new t.Point(this.elParent.clientWidth-this.__props.svgChartBorderdistance-this.__yAxes[0].width,n),h=new t.XVarAxis(this.elParent,this.__props,this.__options);this.__xAxes.push(h),h.drawAxis(a,o),this.__createChartBackground();const l=this.__options.channelConfigurations.slice(0,s.symbols.length).filter(s=>!s.isVisible||s.sourceID==t.Guid.EMPTY_GUID).length,r=this.__options.timeranges.filter(t=>!t.isVisible).length,_=(o.x-a.x)/((this.__options.timeranges.length-r)*(s.symbols.length-l)*1.5);let c=a.x+_/4;for(const i of this.__options.timeranges){if(!i.isVisible)continue;const n=0,a={};a.offsetLeft=c,a.channels=[],a.data=[];for(let o=0;o<this.__options.data.symbols.length;o++){const h=null===(e=this.__channelDataValues.find(t=>t.timerange==i&&t.channelConfig==this.__options.channelConfigurations[o]))||void 0===e?void 0:e.channelData;if(null==h||0==h.length)continue;const l=new t.BarChannel(s.symbols[o],this.__elChartBackground,this.__props,_,c,-this.__yAxes[n].stepDistance,this.__yAxes[n].nullpoint,this.__options.channelConfigurations[o],this.__options);if(this.__options.channelConfigurations[o].isVisible){if(l.drawChannel(h),this.__channels.push(l),a.channels.push(l),c+=1.5*_,-1==a.data.findIndex(t=>t.timestamp==h[h.length-1].timestamp)){const t={timestamp:h[h.length-1].timestamp,values:[]};a.data.push(t)}a.data.find(t=>t.timestamp==h[h.length-1].timestamp).values[o]=h[h.length-1].values[0]}}this.__channelValues.push(a)}this.__channelValues.sort((t,s)=>t.offsetLeft<s.offsetLeft?1:-1),this.__postCreateChart()}__createChannelValues(){const s=JSON.parse(JSON.stringify(this.__options.data));this.__channelDataValues=[];for(const e of this.__options.timeranges){if(!e.isVisible)continue;const i=t.TimeConverter.getFromTcTime(e,this.__props.dataRequestTime),n=t.TimeConverter.getToTcTime(e,this.__props.dataRequestTime);for(let t=0;t<this.__options.data.symbols.length;t++){let a=s.data.map(s=>Object.assign(Object.assign({},s),{values:[s.values[t]]}));if(a=a.filter(t=>t.timestamp<=n&&t.timestamp>=i&&null!=t.values[0]),0==a.length)continue;const o=a[a.length-1];if(this.__options.showDifferentials){const t=a[0];o.values[0]=o.values[0]-t.values[0]}const h={};h.timerange=e,h.channelConfig=this.__options.channelConfigurations[t],h.channelData=[o],this.__channelDataValues.push(h)}}}getValues(s,e){this.__channelValues.forEach(t=>t.channels.forEach(t=>t.elBars.forEach(t=>t.fillOpacity=1)));for(const i of this.__channelValues)if(i.offsetLeft<=s){let n=null;for(const a of i.channels){const i=a.elBars[0];if(null==i)continue;i.x<=s&&s<=i.x+i.width&&i.y<=e&&e<=i.y+i.height&&(i.fillOpacity=.7,n=a.symbol);const o=i.y>=this.__yAxes[0].nullpoint?i.height:0;let h=new t.SVGCircle(i.x+i.width/2,i.y+o+this.__options.hoverPointRadius/2,this.__options.hoverPointRadius,["tchmi-analytics-charting-hover-circle"]);h.appendTo(this.__elChartBackground),h.fill=i.fill,h.stroke="black",this.__hoverPoints.push(h)}return i.data.map(t=>Object.assign(Object.assign({},t),{hoverChannel:n}))}return null}}t.BarChart=s}(t.Analytics||(t.Analytics={}))}(t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));